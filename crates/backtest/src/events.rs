use chrono::{DateTime, Utc};
use ea_okx_core::models::OrderSide;
use ea_okx_core::Symbol;
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// Import Candle from engine module
use crate::engine::Candle;

/// Market event types that can occur during backtesting
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MarketEvent {
    /// New candle data arrived
    Candle(Candle),

    /// Trade tick occurred
    Trade {
        symbol: Symbol,
        price: Decimal,
        quantity: Decimal,
        side: OrderSide,
        timestamp: DateTime<Utc>,
    },

    /// Order book snapshot
    OrderBook {
        symbol: Symbol,
        bids: Vec<(Decimal, Decimal)>, // (price, quantity)
        asks: Vec<(Decimal, Decimal)>,
        timestamp: DateTime<Utc>,
    },
}

impl MarketEvent {
    pub fn timestamp(&self) -> DateTime<Utc> {
        match self {
            MarketEvent::Candle(candle) => candle.timestamp,
            MarketEvent::Trade { timestamp, .. } => *timestamp,
            MarketEvent::OrderBook { timestamp, .. } => *timestamp,
        }
    }

    pub fn symbol(&self) -> &Symbol {
        match self {
            MarketEvent::Candle(candle) => &candle.symbol,
            MarketEvent::Trade { symbol, .. } => symbol,
            MarketEvent::OrderBook { symbol, .. } => symbol,
        }
    }
}

/// Execution event generated by the backtesting engine
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExecutionEvent {
    /// Order was filled
    OrderFilled {
        order_id: Uuid,
        symbol: Symbol,
        side: OrderSide,
        filled_price: Decimal,
        filled_quantity: Decimal,
        commission: Decimal,
        timestamp: DateTime<Utc>,
    },

    /// Order was rejected
    OrderRejected {
        order_id: Uuid,
        reason: String,
        timestamp: DateTime<Utc>,
    },

    /// Order was cancelled
    OrderCancelled {
        order_id: Uuid,
        timestamp: DateTime<Utc>,
    },

    /// Position was opened
    PositionOpened {
        position_id: Uuid,
        symbol: Symbol,
        side: OrderSide,
        entry_price: Decimal,
        quantity: Decimal,
        timestamp: DateTime<Utc>,
    },

    /// Position was closed
    PositionClosed {
        position_id: Uuid,
        exit_price: Decimal,
        pnl: Decimal,
        timestamp: DateTime<Utc>,
    },
}

/// Fill model for simulating order execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Fill {
    pub order_id: Uuid,
    pub price: Decimal,
    pub quantity: Decimal,
    pub commission: Decimal,
    pub timestamp: DateTime<Utc>,
    pub slippage: Decimal,
}

/// Trade record for audit trail
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Trade {
    pub id: Uuid,
    pub strategy_id: Uuid,
    pub symbol: Symbol,
    pub side: OrderSide,
    pub entry_time: DateTime<Utc>,
    pub entry_price: Decimal,
    pub quantity: Decimal,
    pub exit_time: Option<DateTime<Utc>>,
    pub exit_price: Option<Decimal>,
    pub pnl: Decimal,
    pub commission: Decimal,
    pub slippage: Decimal,
    pub max_adverse_excursion: Decimal,   // MAE
    pub max_favorable_excursion: Decimal, // MFE
}

impl Trade {
    pub fn new(
        strategy_id: Uuid,
        symbol: Symbol,
        side: OrderSide,
        entry_time: DateTime<Utc>,
        entry_price: Decimal,
        quantity: Decimal,
        commission: Decimal,
        slippage: Decimal,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            strategy_id,
            symbol,
            side,
            entry_time,
            entry_price,
            quantity,
            exit_time: None,
            exit_price: None,
            pnl: Decimal::ZERO,
            commission,
            slippage,
            max_adverse_excursion: Decimal::ZERO,
            max_favorable_excursion: Decimal::ZERO,
        }
    }

    pub fn close(
        &mut self,
        exit_time: DateTime<Utc>,
        exit_price: Decimal,
        exit_commission: Decimal,
        exit_slippage: Decimal,
    ) {
        self.exit_time = Some(exit_time);
        self.exit_price = Some(exit_price);

        // Calculate PnL
        let price_diff = match self.side {
            OrderSide::Buy => exit_price - self.entry_price,
            OrderSide::Sell => self.entry_price - exit_price,
        };

        let gross_pnl = price_diff * self.quantity;
        let total_commission = self.commission + exit_commission;
        let total_slippage = self.slippage + exit_slippage;

        self.pnl = gross_pnl - total_commission - total_slippage;
    }

    pub fn is_open(&self) -> bool {
        self.exit_time.is_none()
    }

    pub fn duration(&self) -> Option<chrono::Duration> {
        self.exit_time.map(|exit| exit - self.entry_time)
    }
}
